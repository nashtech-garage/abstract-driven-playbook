<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADD Architecture Deep Dive</title>
    <style>
        :root { --grad-start: #6d28d9; --grad-end: #dc2626; --accent: #dc2626; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; font-family: "Segoe UI", Roboto, sans-serif; background: #fff; color: #374151; }
        .container { padding: 3rem 4rem 5rem; height: calc(100% - 12px); }
        h1 { font-size: 3rem; color: var(--accent); margin-bottom: 2rem; }
        h2 { font-size: 2rem; color: var(--grad-start); margin: 1.5rem 0 1rem; }
        ul { list-style: none; font-size: 1.4rem; line-height: 2.3rem; }
        ul li::before { content: "• "; color: var(--accent); font-size: 2rem; margin-right: .4rem; }
        .bottom-bar { position: fixed; bottom: 0; left: 0; height: 12px; width: 100%; background: linear-gradient(90deg, var(--grad-start), var(--grad-end)); }
        mark { background: #fffbcc; }
        .slide { display: none; }
        .slide.active { display: block; }
        .controls { position: fixed; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 10; }
        .btn { background: #222; color: #fff; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; }
        .progress { position: fixed; top: 0; left: 0; height: 4px; background: linear-gradient(90deg, var(--grad-start), var(--grad-end)); transition: width 0.3s; z-index: 10; }
        .diagram { text-align: center; margin: 2rem 0; }
        .code { background: #f8f9fa; padding: 1rem; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 1rem; margin: 1rem 0; }
    </style>
</head>
<body>
    <div class="progress" id="progress"></div>

    <!-- Slide 1: Golden Rule -->
    <div class="slide active">
        <div class="container">
            <h1>ADD – The Golden Rule</h1>
            <ul>
                <li>Absolute separation between <strong>WHAT</strong> (business) and <strong>HOW</strong> (technology).</li>
                <li>Business orchestration depends <em>only</em> on abstract <mark>Ports (interfaces)</mark>.</li>
                <li>Concrete technology (DB, MQ, 3rd-party) lives in <em>Implementations</em>, wired via DI at Bootstrap.</li>
                <li>Operators and Implementations never reference each other directly.</li>
                <li>This one rule keeps the architecture clean and evolvable even when AI generates code.</li>
            </ul>
        </div>
        <div class="bottom-bar"></div>
    </div>

    <!-- Slide 2: 5 Actors -->
    <div class="slide">
        <div class="container">
            <h1>The 5 Actors</h1>
            <h2>1. Boundary</h2>
            <ul>
                <li>System ingress/egress (DTO, API, Boundary Events)</li>
                <li>External contracts and interfaces</li>
            </ul>
            <h2>2. Core Abstractions</h2>
            <ul>
                <li>Common language: thin Entities + Ports + Core Events</li>
                <li>Business vocabulary and contracts</li>
            </ul>
            <h2>3. Operators</h2>
            <ul>
                <li>Business orchestrators, mapping DTO ↔ Entity</li>
                <li>Pure business logic coordination</li>
            </ul>
        </div>
        <div class="bottom-bar"></div>
    </div>

    <!-- Slide 3: 5 Actors Continued -->
    <div class="slide">
        <div class="container">
            <h1>The 5 Actors (continued)</h1>
            <h2>4. Implementations</h2>
            <ul>
                <li>Concrete tools (DB, MQ, 3rd-party integrations)</li>
                <li>Technology-specific adapters</li>
                <li>Anti-corruption layers</li>
            </ul>
            <h2>5. Bootstrap</h2>
            <ul>
                <li>DI wiring and configuration</li>
                <li>Application startup</li>
                <li><mark>No business logic</mark></li>
            </ul>
        </div>
        <div class="bottom-bar"></div>
    </div>

    <!-- Slide 4: Layer Diagram -->
    <div class="slide">
        <div class="container">
            <h1>Layer Dependencies</h1>
            <div class="diagram">
                <div class="code">
┌─────────────────┐    ┌─────────────────┐
│    Boundary     │────│ Core Abstractions│
└─────────────────┘    └─────────────────┘
         ↑                       ↑
         │                       │
┌─────────────────┐              │
│   Operators     │──────────────┘
└─────────────────┘
         ↑
         │
┌─────────────────┐    ┌─────────────────┐
│   Bootstrap     │────│ Implementations │
└─────────────────┘    └─────────────────┘
                               │
                               ↓
                    ┌─────────────────┐
                    │ Core Abstractions│
                    └─────────────────┘
                </div>
            </div>
            <ul>
                <li>Operators depend on Boundary + Core Abstractions only</li>
                <li>Implementations depend on Core Abstractions only</li>
                <li>Bootstrap wires everything together</li>
            </ul>
        </div>
        <div class="bottom-bar"></div>
    </div>

    <!-- Slide 5: Data Flow -->
    <div class="slide">
        <div class="container">
            <h1>Data & Event Flow</h1>
            <div class="code">
External → Boundary → Operators → Implementations
   ↑                     ↓              ↓
   └──── Response DTO ←──┘              │
                                        ↓
                             Core Events (internal)
            </div>
            <ul>
                <li><strong>DTO ↔ Entity mapping</strong> happens in Operators</li>
                <li><strong>Core Events</strong> for internal communication</li>
                <li><strong>Boundary Events</strong> for external integration</li>
                <li>Clean separation of concerns</li>
            </ul>
        </div>
        <div class="bottom-bar"></div>
    </div>

    <!-- Slide 6: DIP in Action -->
    <div class="slide">
        <div class="container">
            <h1>Dependency Inversion in Action</h1>
            <div class="code">
// Core Abstractions - Interface
interface IUserRepository {
  save(user: User): Promise&lt;void&gt;;
  findById(id: string): Promise&lt;User&gt;;
}

// Operators - Depends on abstraction
class UserOperator {
  constructor(private userRepo: IUserRepository) {}
}

// Implementations - Implements interface
class PostgresUserRepository implements IUserRepository {
  // DB-specific implementation
}

// Bootstrap - Wires concrete to abstract
container.bind(IUserRepository).to(PostgresUserRepository);
            </div>
        </div>
        <div class="bottom-bar"></div>
    </div>

    <!-- Slide 7: Benefits -->
    <div class="slide">
        <div class="container">
            <h1>ADD Benefits</h1>
            <ul>
                <li><strong>Technology Independence:</strong> Replace DB/MQ without touching business</li>
                <li><strong>AI-friendly:</strong> Clear contracts guide AI code generation</li>
                <li><strong>Easy Testing:</strong> Unit tests for Implementations, Integration tests for Operators</li>
                <li><strong>Evolvable:</strong> Add new features without architectural drift</li>
                <li><strong>Team Scaling:</strong> Different teams can own different layers</li>
                <li><strong>Deployment Safety:</strong> Side-by-side deployment of new implementations</li>
            </ul>
        </div>
        <div class="bottom-bar"></div>
    </div>

    <div class="controls">
        <button class="btn" onclick="prevSlide()">← Prev</button>
        <button class="btn" onclick="nextSlide()">Next →</button>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const progress = document.getElementById('progress');

        function showSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + slides.length) % slides.length;
            slides[currentSlide].classList.add('active');
            progress.style.width = ((currentSlide + 1) / slides.length * 100) + '%';
        }

        function nextSlide() { showSlide(currentSlide + 1); }
        function prevSlide() { showSlide(currentSlide - 1); }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') nextSlide();
            if (e.key === 'ArrowLeft') prevSlide();
        });

        showSlide(0);
    </script>
</body>
</html>